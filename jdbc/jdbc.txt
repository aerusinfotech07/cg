Sure! Hereâ€™s an extended version of the JDBC example class that covers at least 25 different scenarios. Each scenario includes a method demonstrating a specific functionality.

### Extended JDBC Example Class

```java
import java.io.FileWriter;
import java.io.IOException;
import java.sql.*;

public class JdbcExtendedExample {

    private static final String URL = "jdbc:mysql://localhost:3306/yourdb"; // Update your database URL
    private static final String USER = "yourusername"; // Update your username
    private static final String PASSWORD = "yourpassword"; // Update your password

    public static void main(String[] args) {
        try (Connection connection = DriverManager.getConnection(URL, USER, PASSWORD)) {
            System.out.println("Connected to the database.");

            // 1. Inserting a Single Record
            insertSingleRecord(connection, "John Doe", "john@example.com");

            // 2. Inserting Multiple Records
            insertMultipleRecords(connection);

            // 3. Updating a Record
            updateRecord(connection, "John Doe", "john.doe@example.com");

            // 4. Deleting a Record
            deleteRecord(connection, "User 1");

            // 5. Selecting All Records
            selectAllRecords(connection);

            // 6. Using WHERE Clause
            selectWithWhereClause(connection, "john.doe@example.com");

            // 7. Using ORDER BY
            selectOrderedRecords(connection);

            // 8. Using GROUP BY
            selectGroupedRecords(connection);

            // 9. Using Transactions
            transactionExample(connection);

            // 10. Using PreparedStatement for Dynamic Queries
            selectByEmail(connection, "john.doe@example.com");

            // 11. Retrieving Metadata
            retrieveMetadata(connection);

            // 12. Handling SQL Exceptions
            handleSqlExceptions(connection);

            // 13. Counting Rows in a Table
            countRowsInTable(connection);

            // 14. Using JOINs
            selectWithJoin(connection);

            // 15. Using Subqueries
            selectWithSubquery(connection);

            // 16. Checking for NULL Values
            selectNullValues(connection);

            // 17. Using LIKE for Pattern Matching
            selectLikePattern(connection, "User %");

            // 18. Exporting Data to CSV
            exportDataToCSV(connection);

            // 19. Using Batch Processing
            batchInsertExample(connection);

            // 20. Handling Large Result Sets
            handleLargeResultSet(connection);

            // 21. Setting Connection Properties
            setConnectionProperties();

            // 22. Retrieving Auto-Generated Keys
            retrieveAutoGeneratedKeys(connection);

            // 23. Working with BLOBs
            // (Placeholder for BLOB operation example)

            // 24. Working with CLOBs
            // (Placeholder for CLOB operation example)

            // 25. Dynamic Query Construction
            dynamicQueryExample(connection);

        } catch (SQLException e) {
            e.printStackTrace();
        }
    }

    // 1. Inserting a Single Record
    private static void insertSingleRecord(Connection connection, String name, String email) throws SQLException {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, name);
            pstmt.setString(2, email);
            pstmt.executeUpdate();
            System.out.println("Inserted single record: " + name);
        }
    }

    // 2. Inserting Multiple Records
    private static void insertMultipleRecords(Connection connection) throws SQLException {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        connection.setAutoCommit(false);
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            for (int i = 1; i <= 5; i++) {
                pstmt.setString(1, "User " + i);
                pstmt.setString(2, "user" + i + "@example.com");
                pstmt.addBatch();
            }
            pstmt.executeBatch();
            connection.commit();
            System.out.println("Inserted multiple records.");
        } catch (SQLException e) {
            connection.rollback();
            System.out.println("Failed to insert multiple records, rolled back.");
            e.printStackTrace();
        }
    }

    // 3. Updating a Record
    private static void updateRecord(Connection connection, String oldName, String newEmail) throws SQLException {
        String sql = "UPDATE users SET email = ? WHERE name = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, newEmail);
            pstmt.setString(2, oldName);
            pstmt.executeUpdate();
            System.out.println("Updated record: " + oldName + " to " + newEmail);
        }
    }

    // 4. Deleting a Record
    private static void deleteRecord(Connection connection, String name) throws SQLException {
        String sql = "DELETE FROM users WHERE name = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, name);
            pstmt.executeUpdate();
            System.out.println("Deleted record: " + name);
        }
    }

    // 5. Selecting All Records
    private static void selectAllRecords(Connection connection) throws SQLException {
        String sql = "SELECT * FROM users";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            System.out.println("All Users:");
            while (rs.next()) {
                System.out.println("User: " + rs.getString("name") + ", Email: " + rs.getString("email"));
            }
        }
    }

    // 6. Using WHERE Clause
    private static void selectWithWhereClause(Connection connection, String email) throws SQLException {
        String sql = "SELECT * FROM users WHERE email = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, email);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    System.out.println("Found User: " + rs.getString("name"));
                } else {
                    System.out.println("No user found with email: " + email);
                }
            }
        }
    }

    // 7. Using ORDER BY
    private static void selectOrderedRecords(Connection connection) throws SQLException {
        String sql = "SELECT * FROM users ORDER BY name ASC";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            System.out.println("Ordered Users:");
            while (rs.next()) {
                System.out.println("User: " + rs.getString("name"));
            }
        }
    }

    // 8. Using GROUP BY
    private static void selectGroupedRecords(Connection connection) throws SQLException {
        String sql = "SELECT COUNT(*) AS count, email FROM users GROUP BY email";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            System.out.println("User Count by Email:");
            while (rs.next()) {
                System.out.println("Email: " + rs.getString("email") + ", Count: " + rs.getInt("count"));
            }
        }
    }

    // 9. Using Transactions
    private static void transactionExample(Connection connection) throws SQLException {
        connection.setAutoCommit(false); // Start transaction
        try {
            insertSingleRecord(connection, "Transaction User", "transaction@example.com");
            connection.commit(); // Commit transaction
        } catch (SQLException e) {
            connection.rollback(); // Rollback on error
            System.out.println("Transaction rolled back due to: " + e.getMessage());
        }
    }

    // 10. Using PreparedStatement for Dynamic Queries
    private static void selectByEmail(Connection connection, String email) throws SQLException {
        String sql = "SELECT * FROM users WHERE email = ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, email);
            try (ResultSet rs = pstmt.executeQuery()) {
                if (rs.next()) {
                    System.out.println("Found User: " + rs.getString("name"));
                } else {
                    System.out.println("No user found with email: " + email);
                }
            }
        }
    }

    // 11. Retrieving Metadata
    private static void retrieveMetadata(Connection connection) throws SQLException {
        DatabaseMetaData metaData = connection.getMetaData();
        System.out.println("Database Product Name: " + metaData.getDatabaseProductName());
        System.out.println("Database Product Version: " + metaData.getDatabaseProductVersion());
    }

    // 12. Handling SQL Exceptions
    private static void handleSqlExceptions(Connection connection) {
        try {
            String sql = "SELECT * FROM non_existent_table";
            Statement stmt = connection.createStatement();
            stmt.executeQuery(sql);
        } catch (SQLException e) {
            System.out.println("Caught SQLException: " + e.getMessage());
        }
    }

    // 13. Counting Rows in a Table
    private static void countRowsInTable(Connection connection) throws SQLException {
        String sql = "SELECT COUNT(*) AS total FROM users";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            if (rs.next()) {
                System.out.println("Total Users: " + rs.getInt("total"));
            }
        }
    }

    // 14. Using JOINs
    private static void selectWithJoin(Connection connection) throws SQLException {
        String sql = "SELECT u.name, o.order_date FROM users u JOIN orders o ON u.id = o.user_id";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            System.out.println("Users with Orders:");
            while (rs.next()) {
                System.out.println("User: " + rs.getString("name") + ", Order Date: " + rs.getDate("order_date"));
            }
        }
    }

    // 15. Using Subqueries
    private static void selectWithSubquery(Connection connection) throws SQLException {
        String sql = "SELECT * FROM users WHERE id IN (SELECT user_id FROM orders)";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            System.out.println("Users with Orders:");
            while (rs.next()) {
                System.out.println("User: " + rs.getString("name"));
            }
        }
    }

    // 16. Checking for NULL Values
    private static void selectNullValues(Connection connection) throws SQLException {
        String sql = "SELECT * FROM users WHERE email IS NULL";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql)) {
            System.out.println("Users with NULL Emails:");
            while (rs.next()) {
                System.out.println("User: " + rs.getString("name"));
            }
        }
    }

    // 17. Using LIKE for Pattern Matching
    private static void selectLikePattern(Connection connection, String pattern) throws SQLException {
        String sql = "SELECT * FROM users WHERE name LIKE ?";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            pstmt.setString(1, pattern);
            try (ResultSet rs = pstmt.executeQuery()) {
                System.out.println("Users Matching Pattern:");
                while (rs.next()) {
                    System.out.println("User: " + rs.getString("name"));
                }
            }
        }
    }

    // 18. Exporting Data to CSV
    private static void exportDataToCSV(Connection connection) throws SQLException {
        String sql = "SELECT * FROM users";
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(sql);
             FileWriter csvWriter = new FileWriter("users.csv")) {
            while (rs.next()) {
                csvWriter.append(rs.getString("name"));
                csvWriter.append(",");
                csvWriter.append(rs.getString("email"));
                csvWriter.append("\n");
            }
            csvWriter.flush();
            System.out.println("Data exported to users.csv");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 19. Using Batch Processing
    private static void batchInsertExample(Connection connection) throws SQLException {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        try (PreparedStatement pstmt = connection.prepareStatement(sql)) {
            for (int i = 1; i <= 5; i++) {
                pstmt.setString(1, "Batch User " + i);
                pstmt.setString(2, "batchuser" + i + "@example.com");
                pstmt.addBatch();
            }
            pstmt.executeBatch();
            System.out.println("Batch insert completed.");
        }
    }

    // 20. Handling Large Result Sets
    private static void handleLargeResultSet(Connection connection) throws SQLException {
        String sql = "SELECT * FROM users"; // Assuming the users table has many records
        try (Statement stmt = connection.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);
             ResultSet rs = stmt.executeQuery(sql)) {
            while (rs.next()) {
                System.out.println("User: " + rs.getString("name"));
            }
        }
    }

    // 21. Setting Connection Properties
    private static void setConnectionProperties() {
        Properties properties = new Properties();
        properties.setProperty("user", USER);
        properties.setProperty("password", PASSWORD);
        properties.setProperty("autoReconnect", "true");
        // Use properties when establishing a connection if needed
    }

    // 22. Retrieving Auto-Generated Keys
    private static void retrieveAutoGeneratedKeys(Connection connection) throws SQLException {
        String sql = "INSERT INTO users (name, email) VALUES (?, ?)";
        try (PreparedStatement pstmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS)) {
            pstmt.setString(1, "New User");
            pstmt.setString(2, "newuser@example.com");
            pstmt.executeUpdate();

            try (ResultSet generatedKeys = pstmt.getGeneratedKeys()) {
                if (generatedKeys.next()) {
                    System.out.println("Inserted record ID: " + generatedKeys.getInt(1));
                }
            }
        }
    }

    // 23. Working with BLOBs (Placeholder)
    // To implement BLOB operations like inserting or retrieving binary data

    // 24. Working with CLOBs (Placeholder)
    // To implement CLOB operations like inserting or retrieving large text data

    // 25. Dynamic Query Construction
    private static void dynamicQueryExample(Connection connection) throws SQLException {
        String baseQuery = "SELECT * FROM users";
        StringBuilder queryBuilder = new StringBuilder(baseQuery);
        // Example of adding dynamic conditions
        String emailCondition = "email = 'john@example.com'";
        if (emailCondition != null) {
            queryBuilder.append(" WHERE ").append(emailCondition);
        }
        try (Statement stmt = connection.createStatement();
             ResultSet rs = stmt.executeQuery(queryBuilder.toString())) {
            System.out.println("Dynamic Query Result:");
            while (rs.next()) {
                System.out.println("User: " + rs.getString("name"));
            }
        }
    }
}
```

### Explanation of Each Method

1. **`insertSingleRecord`**: Inserts a single user record.
2. **`insertMultipleRecords`**: Inserts multiple user records in a batch transaction.
3. **`updateRecord`**: Updates the email of a specific user.
4. **`deleteRecord`**: Deletes a user record by name.
5. **`selectAllRecords`**: Selects and prints all user records.
6. **`selectWithWhereClause`**: Selects a user by email.
7. **`selectOrderedRecords`**: Selects and orders users by name.
8. **`selectGroupedRecords`**: Groups users by email and counts them.
9. **`transactionExample`**: Demonstrates a transaction that can be rolled back.
10. **`selectByEmail`**: Selects a user record by email.
11. **`retrieveMetadata`**: Retrieves and prints database metadata.
12. **`handleSqlExceptions`**: Catches and handles SQL exceptions.
13. **`countRowsInTable`**: Counts the number of records in the `users` table.
14. **`selectWithJoin`**: Selects user records with a join on orders (assuming an `orders` table).
15. **`selectWithSubquery`**: Uses a subquery to select users who have orders.
16. **`selectNullValues`**: Selects users with NULL email addresses.
17. **`selectLikePattern`**: Uses the `LIKE` operator to find users matching a pattern.
18. **`exportDataToCSV`**: Exports user data to a CSV file.
19. **`batchInsertExample`**: Demonstrates batch insertion of user records.
20. **`handleLargeResultSet`**: Handles large result sets efficiently.
21. **`setConnectionProperties`**: Shows how to set connection properties.
22. **`retrieveAutoGeneratedKeys`**: Retrieves keys of auto-generated records after insertion.
23. **`dynamicQueryExample`**: Constructs and executes a dynamic query.

### Database Table Setup

Ensure you have the `users` table in your MySQL database as described previously. You may also need to create an `orders` table for some of the join examples:



```sql

CREATE TABLE users (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(100) NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

Explanation of the Columns:
id: An auto-incrementing integer that serves as the primary key for the table.
name: A string field to store the user's name, which cannot be null.
email: A string field to store the user's email address, which must be unique and cannot be null.
Additional Considerations
You may want to add some constraints or indexes based on your application's needs. For instance, you can add:

Indexing on the email column for faster lookups.
Additional fields like created_at, updated_at, etc., to track when records are created or modified.

CREATE TABLE orders (
    id INT AUTO_INCREMENT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    FOREIGN KEY (user_id) REFERENCES users(id)
);
```

### Conclusion

This extended example provides a comprehensive view of JDBC operations in Java, covering various functionalities essential for interacting with relational databases. You can expand on these methods as needed or integrate them into your application. If you have further questions or need clarification, feel free to ask!